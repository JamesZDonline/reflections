What happens when you initialize a repository? Why do you need to do it?

When you initialize a repository, it creates a hidden file called .git which is used to store metadata necessary for version control. 


How is the staging area different from the working directory and the repository? What value do you think it offers?

The staging area may only contain some of the files in the working directory. Unlike the repository, it does not track previous versions of the file, instead it simply records which of the files are currently being tracked by the repository. This allows you to control what commits you make when.


How can you use the staging area to make sure you have one commit per logical change?

By using the commands git diff or git diff --staged, it is possible to see the changes that are occuring within a particular file before it is committed. At that point, if everything looks like it is part of a single logical change, it is possible to decide what exactly to commit and what not to.


What are some situations when branches would be helpful in keeping your history organized? How would branches help?

Branches could help when wanting to test out adding some new features to a project without modifying the original. It could especially be helpful if one was collaborating on a project, so different people could add different things and then maybe find a way to merge the branches back together as was alluded to in the video.


How do the diagrams help you visualize the branch structure?

Diagrams allow you to see how all of the different branches are connected and see what the parents of each commit is. This also helps you to see if there are any commits in danger of being lost.


What is the result of merging two branches together? Why do we represent it in the diagram the way we do?

The two branches were merged together and now features from both branches are present in a single branch. The diagram simply shows what is going on by showing the two merged branches coming together into a single commit.
Note: it was a little harder to merge than I'd thought. The two branches wouldn't merge for some reason, it kept saying there was a conflict. I finally got it to merge by going back to an earlier version and then redoing the modifications I had made.


What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges manually?

The nice thing about Git's automatic merging is that if there was only one set of changes to a secion of code, then those can be automatically introduced, hopefully without breaking anything. It seems to me though that a drawback could be that if the person modifing the code were to make changes that fundamentally changed the functionality, it could break other things without anyone being aware because there were no conflicts. This could be handled by merging manually but that process could be very very tiresome.
